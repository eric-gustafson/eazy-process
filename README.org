
#+startup: showall

* Status

incomplete

* Goals

+ [X] Implementation-agnostic process handling / subshell invocation through cffi, fork, exec
  + pros: arbitrary number of fd's
  + pros: full power of pipe, mkfifo, sockets
  + cons: implicit blocking of wait(2) by some host lisp implementations ?
+ [ ] Memory / Walltime management of the child processes
  + [ ] +hierarchycal model+ --- granpa/gramma won't care
  + [ ] maybe also include network/IO restriction
+ [-] Compatibility layer to the existing State-of-the-Art libraries 
  + [X] trivial-shell
  + [ ] inferior-shell
  + [ ] sb-ext:run-program

* Simple syntax

#+BEGIN_SRC lisp
(defun shell (argv &optional
               (fdspecs '(:in :out :out))
               (environments nil env-p)
               (search t))
    ...)
#+END_SRC

** Fdspecs

: fdspecs := {fdspec}*
: fdspec  := output | input | fd | openfilespec
: output  := :output | :out | :o
: input   := :input | :in | :i
: fd      := <number>
: openfilespec := (pathname &key direction if-exists if-does-not-exist)

--- openfilespec is almost identical to the argument list of =OPEN= in ANSI
spec, however =:rename= and =:rename-and-delete= is not supported.

** Environments

: environments := {environment}*
: environment  := enc-pair | env-string
: env-pair     := (name . value)
: env-string   := "name=value"
: name, value -- string

If we omit the second argument =environments=,
the subprocess inherits the environment of the parent lisp process.
If you give =nil= explicitly, then it means the child process has no
environment at all.

* Usage

#+BEGIN_SRC lisp
  (multiple-value-bind (read write) (pipe)
    (let* ((in "t/test-input")
           (out "t/test-output")
           (err "t/test-error")
           (p1 (shell '("cat") `((,in :direction :input) ,write :out)))
           (p2 (shell '("cat") `(,read
                                 (,out :direction :output
                                       :if-does-not-exist :create)
                                 (,err :direction :output
                                       :if-does-not-exist :create)))))
      (wait p1)
      (wait p2)))
#+END_SRC

+ Async by default. no wait !
+ Even if you forget waiting the process, it is handled by trivial-garbage
  --- when a process object (here, p1 and p2) is GC-ed, it is automatically
  kill(2)ed and wait(2)ed. When the process is still alive after SIGTERM,
  we also finish it with SIGKILL.

** inferior-shell interface

=*bourne-comatible-shell*= is replaced with =*interpreter*=

#+BEGIN_SRC lisp
(shell-command "expr 1 + 2 + 3 + 4") ; --> "10\n"

(let ((*interpreter* "bash -c"))
  (shell-command "echo {1..3}")) ; --> "1 2 3\n"

(let ((*interpreter* "perl -e"))
 (shell-command "print(1+3)"))   ; --> "4"
#+END_SRC

** inferior-shell

TBP

** sb-ext:run-program

TBP

* Library selection

I have searched for ways to manage the memory usage of processes in a
hierarchycal manner while keeping the implementation/OS-independency.

1. libcgroup was rejected because it only targets Linux, while I see many
   other people running Mac OS X on their fancy laptops (well, I'm a
   dedicated fan of thinkpad X-series since X20...)
2. Procfs, in pathnames. Rejected because it seemed slow.
3. libprocps. Rejected because the library design is owful, as described in
   https://gitorious.org/procps/pages/The_libprocps_redesign
4. Now towards hwloc. It is used by htop, torque, OpenMPI. Holds wide
   variety of unix platforms, including Darwin and windows. --- it seems
   the purpose of the library seems different.
5. Back to procps. This time, saw the C source code instead of just the
   header files. They are reading the /proc ... ewww. Better reading by
   lispselves. However, procfs is not available on the other platforms again...
6. http://pythonhosted.org/psutil/ is using different implementations for
   different OS'es. uh oh...

* Dependencies
This library is at least tested on implementation listed below:

+ SBCL 1.2.1 on X86-64 Linux 3.13.0-39-generic (author's environment)

Also, it depends on the following libraries:

+ iterate by *Jonathan Amsterdam* :
    Jonathan Amsterdam's iterator/gatherer/accumulator facility
+ alexandria by ** :
    Alexandria is a collection of portable public domain utilities.
+ cffi by *James Bielman  <jamesjb@jamesjb.com>* :
    The Common Foreign Function Interface
+ optima by *Tomohiro Matsuyama* :
    Optimized Pattern Matching Library
+ iolib
+ trivial-garbage
+ cl-rlimit

* Author

Masataro Asai (guicho2.71828@gmail.com)

* Copyright

Copyright (c) 2014 Masataro Asai (guicho2.71828@gmail.com)

