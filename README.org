
#+startup: showall

* What it does

+ Declarative process handling
+ Subprocess spawned by POSIX fork&exec, no impl-specific interface
+ Memory / CPU-time management of the child processes
+ [-] Compatibility layer to the existing State-of-the-Art libraries 
  + [X] trivial-shell
  + [ ] inferior-shell
  + [ ] sb-ext:run-program

* What it doesn't

+ writing to/reading from the input/output of a specific process
+ creating a stream
+ using processes as a subroutine
+ mimicking the shell scripts

* Usage

#+BEGIN_SRC lisp
(defvar pipe (pipe))
(defvar in "t/test-input")
(defvar out "t/test-output")

(defvar p1 (shell '("cat") `((,in   :direction :input) ; fd 0
                             (,pipe :direction :output)))) ; fd 1
(defvar p2 (shell '("cat") `((,pipe :direction :input) ; fd 0
                             (,out  :direction :output)))) ; fd 1

(wait p1)
(wait p2)
#+END_SRC

Processes are async by default.
Even if you forget waiting the process, it is handled by trivial-garbage
--- when a process object (here, p1 and p2) is GC-ed, it is automatically
kill(2)ed and wait(2)ed. When the process is still alive after SIGTERM,
it also finish the process with SIGKILL.

** Implicit Piping

If you do not specify the pipe, a new pipe is implicitly created for each
fd, and the /other/ end of the pipe is accessible with =(fd process fdnum)=.

#+BEGIN_SRC lisp
    (let* ((in "t/test-input")
           (p1 (shell '("cat") `((,in :direction :input) :out :out)))
           (p2 (shell '("cat") `(,(fd p1 1) :out :out))))
      (wait p1)
      (wait p2))
#+END_SRC

** Reading the output

The output of the subprocess can be read from =fd-as-pathname=, which
returns the pathname =/dev/fd/[fd]=.
*EAZY-PROCESS sticks with file descriptors* and do not provide the stream interface.

#+BEGIN_SRC lisp
(test read
  (let ((p1 (shell `("hostname"))))
    (with-open-file (s (fd-as-pathname p1 1))
      (is (string= (machine-instance)
                   (read-line s))))))
#+END_SRC

** Resource management

Macro =with-rlimit= dynamically binds the current rlimit
resource limitation. 
As noted in =*rlimit-resources*= docstring, this does not affect the lisp process itself.
--- It only affect the new child processes spawned by =shell=.

Example below shows the usecase where =*spendtime*= contains a path to a
simple C program that busy-waits for 10 seconds. The execution is
terminated in 3 seconds. TERMSIG is set to 24 because the program
is killed by SIGXCPU.

#+BEGIN_SRC lisp
 (with-rlimit ((+rlimit-cpu-time+ 3)) ; 3 sec
   (let ((p (shell `(,(namestring *spendtime*))))) 
     (multiple-value-bind
            (exited exitstatus ifsignalled termsig ...)
            (wait p)
       (is-false exited)
       (is-false exitstatus)
       (is-true ifsignalled)
       (is (= 24 termsig)))))
#+END_SRC

This macro can be nested, and unlike original rlimit, you can increase the
number (but not above the limit of the lisp process itself).
The new subprocess reflects the inntermost limitation.

#+BEGIN_SRC lisp
(with-rlimit ((+rlimit-cpu-time+ 3))
  (shell ...) ; 3 sec
  (with-rlimit ((+rlimit-cpu-time+ 5)
                (+rlimit-as+ 500000))
    (shell ...))) ; 5 sec, 500 MB
#+END_SRC

* Tested Impl

This library is at least tested on implementation listed below:

+ SBCL 1.2.1 on X86-64 Linux 3.13.0-39-generic (author's environment)
+ SBCL 1.1.14 on X86 Linux 3.13.0-44-generic (author's environment)
+ CCL 1.10 on linux currently has a problem reading =/dev/fd/[fd]=, which
  is actually a symlink to =/proc/[pid]/fd/[fd]=, and the test does not
  pass. Do not use =(fd-as-pathname process fd)= and use temorary
  files instead.
+ ECL opens =/dev/fd/[fd]= correctly, but it fails to load CFFI...
+ ABCL has more problems than CCL. It fails to open =/proc/[pid]/fd/[fd]=
  and also have problems with CFFI.

Test reports on other OS'es/impls are greatly appreciated.
Run =./simple-build-test.sh=, assuming it already loads quicklisp in your
init files.

* Dependencies

It depends on the latest libfixposix available at
https://github.com/sionescu/libfixposix .

Also, it depends on the following libraries:

+ iterate by *Jonathan Amsterdam* :
    Jonathan Amsterdam's iterator/gatherer/accumulator facility
+ Alexandria by ** :
    Alexandria is a collection of portable public domain utilities.
+ cffi by *James Bielman  <jamesjb@jamesjb.com>* :
    The Common Foreign Function Interface
+ optima by *Tomohiro Matsuyama* :
    Optimized Pattern Matching Library
+ iolib
+ trivial-garbage
+ cl-rlimit

* Syntax

#+BEGIN_SRC lisp
(defun shell (argv &optional
               (fdspecs '(:in :out :out))
               (environments nil env-p)
               (search t))
    ...)
#+END_SRC

When =search= is nil, it disables the pathname resolving using PATH.

** Fdspecs

: fdspecs := {fdspec}*
: fdspec  := output | input | fd | openspec
: output  := :output | :out | :o
: input   := :input | :in | :i
: fd      := <fixnum>
: openspec := (path-or-pipe &key direction if-exists if-does-not-exist)
: path-or-pipe := <pipe object> | <pathname>
: direction := :input | :output | :io | :probe
: if-exists := :ovewrite | :supersede | :append | :error
: if-does-not-exist := :create | :error

+ =output= form and =input= form implicitly create a new pipe.
+ Function =pipe= generates a new pipe object that can be used as an fdspec.
+ The fixnum should be a value of function =(fd process fdnum)=.
+ Openfilespec is almost identical to the argument list of =OPEN= in ANSI
  spec, however =:rename=, =:rename-and-delete=, =:new-version= are not
  supported and signals an error.
+ Be careful when you open a fifo, the process will be blocked.

** Environments

: environments := {environment}*
: environment  := env-pair | env-string
: env-pair     := (name . value)
: env-string   := "name=value"
: name, value -- string

If we omit the second argument =environments=,
the subprocess inherits the environment of the parent lisp process.
If you give =nil= explicitly, then it means the child process has no
environment at all.

* Compatibility Layers
** trivial-shell compatibility

Spawns an interpreter like bash, tsch, sh, perl etc. and
returns =(values string string fixnum)=.
Commands are run synchronously, i.e., it always waits for the process to finish.
=shell-command= is implemented with =shell=, therefore it runs where the
resource binding established by =with-rlimit= is in effect.

Note that =*bourne-compatible-shell*= is replaced with =*interpreter*=.

#+BEGIN_SRC lisp
(shell-command "expr 1 + 2 + 3 + 4") ; --> "10\n", "", 0

(shell-command "echo hello >&2") ; --> "", "hello\n", 0

(shell-command "exit 1") ; --> "", "", 1

(let ((*interpreter* "bash -c"))
  (shell-command "echo {1..3}")) ; --> "1 2 3\n", "", 0

(let ((*interpreter* "perl -e"))
 (shell-command "print(1+3)"))   ; --> "4", "", 0
#+END_SRC

** sb-ext:run-program compatibility

TBP

** inferior-shell compatibility

TBP

* Author

Masataro Asai (guicho2.71828@gmail.com)

* Copyright

Copyright (c) 2014 Masataro Asai (guicho2.71828@gmail.com)

