
#+startup: showall

+ +Status: incomplete+
+ Status: sbcl completed

* Goals

+ [X] process handling / subshell invocation through cffi, fork, exec
  + pros: arbitrary number of fd's
  + pros: full power of pipe, mkfifo, sockets
  + cons: implicit blocking of wait(2) by some host lisp implementations ?
+ [ ] Implementation independency
+ [X] Memory / Walltime management of the child processes
  + +hierarchical model+ --- grandpa/gram-ma won't care
  + +maybe also include network/IO restriction+
+ [-] Compatibility layer to the existing State-of-the-Art libraries 
  + [X] trivial-shell
  + [ ] inferior-shell
  + [ ] sb-ext:run-program

* Usage

Describe each process in a declarative manner.
Processes are async by default.

#+BEGIN_SRC lisp
(defvar pipe (pipe))
(defvar in "t/test-input")
(defvar out "t/test-output")

(defvar p1 (shell '("cat") `((,in   :direction :input) ; fd 0
                             (,pipe :direction :output)))) ; fd 1
(defvar p2 (shell '("cat") `((,pipe :direction :input) ; fd 0
                             (,out  :direction :output)))) ; fd 1

(wait p1)
(wait p2)
#+END_SRC

Even if you forget waiting the process, it is handled by trivial-garbage
--- when a process object (here, p1 and p2) is GC-ed, it is automatically
kill(2)ed and wait(2)ed. When the process is still alive after SIGTERM,
we also finish it with SIGKILL.

** Implicit Piping

If you do not specify the pipe, a new pipe is implicitly created for each
fd, and the /other/ end of the pipe is accessible with =(fd process fdnum)=.

#+BEGIN_SRC lisp
    (let* ((in "t/test-input")
           (p1 (shell '("cat") `((,in :direction :input) :out :out)))
           (p2 (shell '("cat") `(,(fd p1 1) :out :out))))
      (wait p1)
      (wait p2))
#+END_SRC

** Reading the output

The output of the subprocess can be read from =fd-as-pathname=, which
returns an address to the proper =/dev/fd/[fd]= connected to the child
process through a pipe.

*EAZY-PROCESS sticks with file descriptors* and do not provide
the interface to the common lisp stream.

#+BEGIN_SRC lisp
(test read
  (let ((p1 (shell `("hostname"))))
    (with-open-file (s (fd-as-pathname p1 1))
      (is (string= (machine-instance)
                   (read-line s))))))
#+END_SRC

** Resource management

Macro =with-rlimit= dynamically binds the current rlimit
resource limitation. 

As noted in =*rlimit-resources*= docstring, this does not affect the lisp process itself.
It only affect the new child processes spawned by =shell=.

Example below shows the usecase where =*spendtime*= contains a path to a
simple C program that busy-waits for 10 seconds. The execution is
terminated in 3 seconds. TERMSIG is set to 24 because the program
is killed by SIGXCPU.

#+BEGIN_SRC lisp
 (with-rlimit ((+rlimit-cpu-time+ 3)) ; 3 sec
   (let ((p (shell `(,(namestring *spendtime*))))) 
     (multiple-value-bind
            (exited exitstatus ifsignalled termsig ...)
            (wait p)
       (is-false exited)
       (is-false exitstatus)
       (is-true ifsignalled)
       (is (= 24 termsig)))))
#+END_SRC

The macro can be nested, and unlike original rlimit, you can increase the
number (but not above the limit of the lisp process itself).
The new subprocess reflects the inntermost limitation.

#+BEGIN_SRC lisp
(with-rlimit ((+rlimit-cpu-time+ 3))
  (shell ...) ; 3 sec
  (with-rlimit ((+rlimit-cpu-time+ 5)
                (+rlimit-as+ 500000))
    (shell ...))) ; 5 sec, 500 MB
#+END_SRC

* Dependencies
This library is at least tested on implementation listed below:

+ SBCL 1.2.1 on X86-64 Linux 3.13.0-39-generic (author's environment)
+ SBCL 1.1.14 on X86 Linux 3.13.0-44-generic (author's environment)
+ CCL 1.9 currently has a problem reading
  =/proc/[pid]/fd/[fd]= and the test does not pass. Do not use
  =(fd-as-pathname process fd)= and use temorary files instead.
+ ECL fails to load CFFI...
+ ABCL has more problems than CCL.

It depends on the latest libfixposix available at
https://github.com/sionescu/libfixposix .

Also, it depends on the following libraries:

+ iterate by *Jonathan Amsterdam* :
    Jonathan Amsterdam's iterator/gatherer/accumulator facility
+ Alexandria by ** :
    Alexandria is a collection of portable public domain utilities.
+ cffi by *James Bielman  <jamesjb@jamesjb.com>* :
    The Common Foreign Function Interface
+ optima by *Tomohiro Matsuyama* :
    Optimized Pattern Matching Library
+ iolib
+ trivial-garbage
+ cl-rlimit

* Syntax

#+BEGIN_SRC lisp
(defun shell (argv &optional
               (fdspecs '(:in :out :out))
               (environments nil env-p)
               (search t))
    ...)
#+END_SRC

When =search= is nil, it disables the pathname resolving using PATH.

** Fdspecs

: fdspecs := {fdspec}*
: fdspec  := output | input | fd | pipe | openfilespec
: output  := :output | :out | :o
: input   := :input | :in | :i
: pipe    := <pipe object>
: fd      := <fixnum>
: openfilespec := (pathname &key direction if-exists if-does-not-exist)
: direction := :input | :output | :io | :probe
: if-exists := :ovewrite | :supersede | :append | :error
: if-does-not-exist := :create | :error

+ =output= form and =input= form implicitly create a new pipe.
+ Function =pipe= generates a new pipe object that can be used as an fdspec.
+ The fixnum should be a value of function =(fd process fdnum)=.
+ Openfilespec is almost identical to the argument list of =OPEN= in ANSI
  spec, however =:rename=, =:rename-and-delete=, =:new-version= are not
  supported and signals an error.
+ Be careful when you open a fifo, the process will be blocked.

** Environments

: environments := {environment}*
: environment  := env-pair | env-string
: env-pair     := (name . value)
: env-string   := "name=value"
: name, value -- string

If we omit the second argument =environments=,
the subprocess inherits the environment of the parent lisp process.
If you give =nil= explicitly, then it means the child process has no
environment at all.

* Compatibility Layers
** trivial-shell compatibility

=*bourne-compatible-shell*= is replaced with =*interpreter*=

#+BEGIN_SRC lisp
(shell-command "expr 1 + 2 + 3 + 4") ; --> "10\n"

(let ((*interpreter* "bash -c"))
  (shell-command "echo {1..3}")) ; --> "1 2 3\n"

(let ((*interpreter* "perl -e"))
 (shell-command "print(1+3)"))   ; --> "4"
#+END_SRC

Since this compatibility layer is implemented with =shell=,
resource binding established by =with-rlimit= is in effect.

** inferior-shell compatibility

TBP

** sb-ext:run-program compatibility

TBP

* Library selection

I have searched for ways to manage the memory usage of processes in a
hierarchycal manner while keeping the implementation/OS-independency.

1. libcgroup was rejected because it only targets Linux, while I see many
   other people running Mac OS X on their fancy laptops (well, I'm a
   dedicated fan of thinkpad X-series since X20...)
2. Procfs, in pathnames. Rejected because it seemed slow.
3. libprocps. Rejected because the library design is awful, as described in
   https://gitorious.org/procps/pages/The_libprocps_redesign
4. Now towards hwloc. It is used by htop, torque, OpenMPI. Holds wide
   variety of unix platforms, including Darwin and windows. --- it seems
   the purpose of the library seems different.
5. Back to procps. This time, saw the C source code instead of just the
   header files. They are reading the /proc ... ewww. Better reading by
   lispselves. However, procfs is not available on the other platforms again...
6. http://pythonhosted.org/psutil/ is using different implementations for
   different OS'es. uh oh...

* Author

Masataro Asai (guicho2.71828@gmail.com)

* Copyright

Copyright (c) 2014 Masataro Asai (guicho2.71828@gmail.com)

